diff --git a/rmk-macro/src/chip_init.rs b/rmk-macro/src/chip_init.rs
index ec509ee4..d558b3a9 100644
--- a/rmk-macro/src/chip_init.rs
+++ b/rmk-macro/src/chip_init.rs
@@ -192,146 +192,6 @@ pub(crate) fn chip_init_default(keyboard_config: &KeyboardTomlConfig, peripheral
                     control.init(clm).await;
                     ::defmt::info!("[cyw43] control.init done");
 
-                    // Log HCI traffic so BLE activity shows up alongside cyw43 logs (raw bytes).
-                    struct Cyw43LogTransport<T>(T);
-                    impl<T> Cyw43LogTransport<T> {
-                        fn new(inner: T) -> Self {
-                            Self(inner)
-                        }
-                    }
-                    impl<T: ::embedded_io::ErrorType> ::embedded_io::ErrorType for Cyw43LogTransport<T> {
-                        type Error = T::Error;
-                    }
-                    struct HciBufWriter<'a> {
-                        buf: &'a mut [u8],
-                        len: usize,
-                        truncated: bool,
-                    }
-                    impl<'a> HciBufWriter<'a> {
-                        fn new(buf: &'a mut [u8]) -> Self {
-                            Self {
-                                buf,
-                                len: 0,
-                                truncated: false,
-                            }
-                        }
-                        fn len(&self) -> usize {
-                            self.len
-                        }
-                        fn truncated(&self) -> bool {
-                            self.truncated
-                        }
-                    }
-                    impl<'a> ::embedded_io::ErrorType for HciBufWriter<'a> {
-                        type Error = ::core::convert::Infallible;
-                    }
-                    impl<'a> ::embedded_io::Write for HciBufWriter<'a> {
-                        fn write(&mut self, buf: &[u8]) -> Result<usize, Self::Error> {
-                            let remaining = self.buf.len().saturating_sub(self.len);
-                            let to_copy = core::cmp::min(remaining, buf.len());
-                            if to_copy > 0 {
-                                self.buf[self.len..self.len + to_copy].copy_from_slice(&buf[..to_copy]);
-                                self.len += to_copy;
-                            }
-                            if to_copy < buf.len() {
-                                self.truncated = true;
-                            }
-                            Ok(buf.len())
-                        }
-                        fn flush(&mut self) -> Result<(), Self::Error> {
-                            Ok(())
-                        }
-                    }
-                    impl<T> ::bt_hci::transport::Transport for Cyw43LogTransport<T>
-                    where
-                        T: ::bt_hci::transport::Transport,
-                        T::Error: ::core::fmt::Debug,
-                    {
-                        async fn read<'a>(&self, rx: &'a mut [u8]) -> Result<::bt_hci::ControllerToHostPacket<'a>, Self::Error> {
-                            let pkt = self.0.read(rx).await?;
-                            let mut buf = [0u8; 300];
-                            let mut idx = 0;
-                            buf[idx] = pkt.kind() as u8;
-                            idx += 1;
-                            match &pkt {
-                                ::bt_hci::ControllerToHostPacket::Acl(p) => {
-                                    let handle = p.handle().raw()
-                                        | ((p.boundary_flag() as u16) << 12)
-                                        | ((p.broadcast_flag() as u16) << 14);
-                                    let data = p.data();
-                                    buf[idx..idx + 2].copy_from_slice(&handle.to_le_bytes());
-                                    idx += 2;
-                                    buf[idx..idx + 2].copy_from_slice(&(data.len() as u16).to_le_bytes());
-                                    idx += 2;
-                                    let to_copy = core::cmp::min(data.len(), buf.len().saturating_sub(idx));
-                                    buf[idx..idx + to_copy].copy_from_slice(&data[..to_copy]);
-                                    idx += to_copy;
-                                }
-                                ::bt_hci::ControllerToHostPacket::Event(p) => {
-                                    let data = p.data;
-                                    buf[idx] = p.kind.0;
-                                    idx += 1;
-                                    buf[idx] = data.len() as u8;
-                                    idx += 1;
-                                    let to_copy = core::cmp::min(data.len(), buf.len().saturating_sub(idx));
-                                    buf[idx..idx + to_copy].copy_from_slice(&data[..to_copy]);
-                                    idx += to_copy;
-                                }
-                                ::bt_hci::ControllerToHostPacket::Sync(p) => {
-                                    let handle = p.handle().raw() | ((p.status() as u16) << 12);
-                                    let data = p.data();
-                                    buf[idx..idx + 2].copy_from_slice(&handle.to_le_bytes());
-                                    idx += 2;
-                                    buf[idx] = data.len() as u8;
-                                    idx += 1;
-                                    let to_copy = core::cmp::min(data.len(), buf.len().saturating_sub(idx));
-                                    buf[idx..idx + to_copy].copy_from_slice(&data[..to_copy]);
-                                    idx += to_copy;
-                                }
-                                ::bt_hci::ControllerToHostPacket::Iso(p) => {
-                                    let has_ts = p
-                                        .data_load_header()
-                                        .map(|h| h.timestamp.is_some())
-                                        .unwrap_or(false);
-                                    let handle = p.handle().raw()
-                                        | ((p.boundary_flag() as u16) << 12)
-                                        | ((has_ts as u16) << 14);
-                                    let data = p.data();
-                                    buf[idx..idx + 2].copy_from_slice(&handle.to_le_bytes());
-                                    idx += 2;
-                                    buf[idx..idx + 2].copy_from_slice(&(data.len() as u16).to_le_bytes());
-                                    idx += 2;
-                                    let to_copy = core::cmp::min(data.len(), buf.len().saturating_sub(idx));
-                                    buf[idx..idx + to_copy].copy_from_slice(&data[..to_copy]);
-                                    idx += to_copy;
-                                }
-                            }
-                            let bytes = ::defmt::Debug2Format(&buf[..idx]);
-                            ::defmt::info!("[cyw43 hci] rx kind={:?} len={} bytes={:?}", pkt.kind(), idx, bytes);
-                            Ok(pkt)
-                        }
-                        async fn write<P: ::bt_hci::HostToControllerPacket>(&self, val: &P) -> Result<(), Self::Error> {
-                            let mut buf = [0u8; 300];
-                            buf[0] = P::KIND as u8;
-                            let mut writer = HciBufWriter::new(&mut buf[1..]);
-                            let _ = val.write_hci(&mut writer);
-                            let used = 1 + writer.len();
-                            let truncated = writer.truncated();
-                            ::core::mem::drop(writer);
-                            let bytes = ::defmt::Debug2Format(&buf[..used]);
-                            ::defmt::info!(
-                                "[cyw43 hci] tx kind={:?} total={} logged={} truncated={} bytes={:?}",
-                                P::KIND,
-                                1 + val.size(),
-                                used,
-                                truncated,
-                                bytes
-                            );
-                            self.0.write(val).await
-                        }
-                    }
-
-                    let bt_device = Cyw43LogTransport::new(bt_device);
                     let controller: ::bt_hci::controller::ExternalController<_, 10> = ::bt_hci::controller::ExternalController::new(bt_device);
                     let ble_addr = #ble_addr;
                     let mut host_resources = ::rmk::HostResources::new();
diff --git a/rmk/src/split/ble/central.rs b/rmk/src/split/ble/central.rs
index 88436d65..2254cf98 100644
--- a/rmk/src/split/ble/central.rs
+++ b/rmk/src/split/ble/central.rs
@@ -380,11 +380,6 @@ async fn run_peripheral_manager<
             )
             .await?;
         info!("Message to central found");
-        info!(
-            "[split central] message_to_central handle=0x{:x} cccd=0x{:x}",
-            message_to_central.handle,
-            message_to_central.cccd_handle.unwrap_or(0)
-        );
         let message_to_peripheral = client
             .characteristic_by_uuid::<[u8; SPLIT_MESSAGE_MAX_SIZE]>(
                 service,
@@ -397,18 +392,6 @@ async fn run_peripheral_manager<
             .await?;
         info!("Subscribing notifications");
         let listener = client.subscribe(&message_to_central, false).await?;
-        info!(
-            "[split central] notif_qsize={}",
-            trouble_host::config::GATT_CLIENT_NOTIFICATION_QUEUE_SIZE
-        );
-        info!(
-            "[split central] pool_size={} mtu={} l2cap_rxq={} l2cap_txq={} conn_ev_qsize={}",
-            trouble_host::config::DEFAULT_PACKET_POOL_SIZE,
-            trouble_host::config::DEFAULT_PACKET_POOL_MTU,
-            trouble_host::config::L2CAP_RX_QUEUE_SIZE,
-            trouble_host::config::L2CAP_TX_QUEUE_SIZE,
-            trouble_host::config::CONNECTION_EVENT_QUEUE_SIZE
-        );
         let split_ble_driver = BleSplitCentralDriver::new(listener, message_to_peripheral, client);
         let peripheral_manager = PeripheralManager::<ROW, COL, ROW_OFFSET, COL_OFFSET, _>::new(split_ble_driver, id);
         peripheral_manager.run().await;
@@ -455,11 +438,6 @@ impl<'a, 'b, 'c, C: Controller + ControllerCmdAsync<LeSetPhy>, P: PacketPool> Sp
     async fn read(&mut self) -> Result<SplitMessage, SplitDriverError> {
         let data = self.listener.next().await;
         let raw = data.as_ref();
-        info!(
-            "[split central] raw bytes len={} bytes={:?}",
-            raw.len(),
-            raw
-        );
         let message = postcard::from_bytes(raw).map_err(|_| SplitDriverError::DeserializeError)?;
         info!("Received split message: {:?}", message);
 
diff --git a/rmk/src/split/ble/peripheral.rs b/rmk/src/split/ble/peripheral.rs
index 6d45a114..a3a3f355 100644
--- a/rmk/src/split/ble/peripheral.rs
+++ b/rmk/src/split/ble/peripheral.rs
@@ -116,32 +116,7 @@ impl<'stack, 'server, 'c, P: PacketPool> SplitWriter for BleSplitPeripheralDrive
             error!("Postcard serialize split message error: {}", e);
             SplitDriverError::SerializeError
         })?;
-        let head_len = if used.len() > 16 { 16 } else { used.len() };
-        info!(
-            "[split peri] serialized len={} head={:?}",
-            used.len(),
-            &used[..head_len]
-        );
         info!("Writing split message to central: {:?}", message);
-        let bytes = defmt::Debug2Format(&buf);
-        info!(
-            "[split peri] notify handle=0x{:x} len={} bytes={:?}",
-            self.message_to_central.handle,
-            buf.len(),
-            bytes
-        );
-        if let SplitMessage::Key(key) = message {
-            if let crate::event::KeyboardEventPos::Key(pos) = key.pos {
-                info!(
-                    "[cyw43 hci] key notify pressed={} row={} col={}",
-                    key.pressed,
-                    pos.row,
-                    pos.col
-                );
-            } else {
-                info!("[cyw43 hci] key notify pressed={}", key.pressed);
-            }
-        }
         self.message_to_central.notify(self.conn, &buf).await.map_err(|e| {
             error!("BLE notify error: {:?}", e);
             SplitDriverError::BleError(1)
diff --git a/rmk/src/split/peripheral.rs b/rmk/src/split/peripheral.rs
index cb06b2aa..8086e6a7 100644
--- a/rmk/src/split/peripheral.rs
+++ b/rmk/src/split/peripheral.rs
@@ -125,11 +125,6 @@ impl<S: SplitWriter + SplitReader> SplitPeripheral<S> {
                     }
                 },
                 embassy_futures::select::Either3::Second(e) => {
-                    info!(
-                        "[split peri] key_event={:?} conn={}",
-                        e,
-                        CONNECTION_STATE.load(core::sync::atomic::Ordering::Acquire)
-                    );
                     #[cfg(feature = "_ble")]
                     let can_send = true;
                     #[cfg(not(feature = "_ble"))]
